#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/********************************************************************
*Struktora do przechowywania wêz³a listy: 			*
* -wskaŸnik na kolejny wêze³ 					*
* -wskaŸnik na poprzedni wêze³ 					*
* -d³ugoœæ napisu w œrodku, inicjalnie 0, po tym iterujemy	*
* -iloœæ miejsca na napis, inicjalnie 32 			*
* -wskaŸnik na napis wewn¹trz 					*
*********************************************************************/
typedef struct node // WÊZE£ LISTY
{
struct node *next; // ->
struct node *prev;  // <-
int length; // 0
int size;   // 0/32 -> 32/64
char* str;  //   char[  ] -> realloc pod to samo miejsce, size x2
} node;

typedef struct OrganizacjaListy
{
struct node *first;
struct node *last;
struct node *actual;
int counter;
int max_size;
} OrgList;
/********************************************************************
*Funkcja dodaj¹ca znak do wêz³a (adres wêz³a, znak do dodania) *
* poczatkowo sprawdzenie czy napis siê zmieœci, *
* jeœli siê nie zmieœci to alokujemy 2 razy tyle pamiêci co by³o *
* *
* wpisanie znaku pod i=rozmiar napisu + 1 *
* *
*********************************************************************/
void append(node *node, char c) // add, DODAJ WÊZE£
{
if (node->length == node->size) // wstêpny warunek na to czy dodatkowy char sie zmiesci w napisie
{
node->size *= 2; // powiekszanie pamieci ze wspolczynnikiem x 2
node->str = realloc(node->str, node->size);
}
node->str[node->length++] = c; // dopisujemy znak do str[aktualna dlugosc napisu++]
}
/********************************************************************
*Funkcja wyœwietlacj¹ca napis ze œrodka wêz³a(adres wêz³a) *
* wyczyszczenie linii po poprzenim napisie *
* wypisanie napisu z danego wêz³a listy *
* *
* *
* *
*********************************************************************/
void display(node *node)
{
printf("\r                                                                               \r"); // powrót do pocz¹tku linii wypisanie 79 spacji i powrót do pocz¹tku linii (CR) - szerokosc konsoli
for (int i = 0; i < node->length; i++)
printf("%c", node->str[i]); // wypisanie calej tablicy znakow spod str[] w petli
}

int main()
{
int c;

node* head = (node *)malloc(sizeof(node)); // inicjalizacja pierwszego wêz³a listy(g³owa), alokacja pamieci pod strukture
head->length = 0; // inicjalnie d³ugoœæ napisu w œrodku: 0
head->prev = NULL; // inicjalnie nie ma el. poprzedniego, wskaŸnik wskazuje na nulla
head->next = NULL; // inicjalnie nie ma el. nastêpnego, wskaŸnik wskazuje na nulla
head->size = 32; // inicjalnie iloœæ miejsca na napis w œrodku : 32
head->str = (char*)malloc(head->size); // alokacja pamiêci pod napis wewn¹trz struktury

OrgList* organizer = (OrgList *)malloc(sizeof(OrgList));
organizer->first = head->prev;
organizer->last = head->next;
organizer->actual = head;
organizer->counter = 0 ;
organizer->max_size = 10;

do // g³ówna pêtla programu
{
c = getch(); //pobiera ka¿dy znak z klawiatury
if (c == ',') //sterowanie na przyciskach < > ,przesuwa w lewo
{
if (head->prev) // sprawdzenie czy w ogóle jest wêze³ wczeœniej
{
head = head->prev; // przesuniecie glowy w <-
display(head);
}
}
else if (c == '.') //sterowanie na przyciskach < > .przesuwa w prawo
{
if (head->next) // sprawdzenie czy w ogóle jest wêze³ póŸniej
{
head = head->next; // przesuniecie glowy w ->
display(head);
}
}
else if (c == '\r') // enter wprowadza kolejny el. do pamiêci -> nowy wêze³ listy
{
if (organizer->counter > 10)
{
//tu kod na zwolnienie najstarszego wezla i przebudowanie listy
}
printf("\r                                        \r"); // ewentualnie mo¿emy po ka¿dym wpisie daæ now¹ liniê
node *oldHead = head; // przepisanie g³owy listy do oldHead
while (head->next != NULL) // dopóki s¹ kolejne elementy listy
head = head->next; // przepisujemy kolejny element do wczeœniejszego
head->length = oldHead->length;
head->size = oldHead->size;
head->str = realloc(head->str, head->size);
memcpy(head->str, oldHead->str, head->length);
head->next = (node*)malloc(sizeof(node));
head->next->prev = head;
head = head->next;
head->length = 0;
head->next = NULL;
head->size = 32;
head->str = (char*)malloc(head->size);
}
else
{
printf("%c", c);
append(head, c);
}
} while (1);
}